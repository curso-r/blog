---
title: "Advent of R: Dia 20"
date: "2021-12-20"
tags: ["advent-of-r", "tidyverse"]
categories: ["Tutoriais"]
image: "images/posts/banner/advent-of-r-20.webp"
author: ["Caio"]
summary: "Resolvendo o Advent of Code 2021 com R: Dia 20."
draft: false
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>O <a href="https://adventofcode.com">Advent of Code</a> é um
<a href="https://pt.wikipedia.org/wiki/Calend%C3%A1rio_do_Advento">Calendário do Advento</a>
desenvolvido por <a href="https://github.com/topaz">Eric Wastl</a> composto por 25
pequenos exercícios de programação que vão sendo disponibilizados, um a um,
entre 1º de dezembro e o Natal de cada ano.</p>
<p>Meu objetivo com o <strong>Advent of R</strong> é resolver todos os problemas do
<a href="https://adventofcode.com/2021">Advent of Code 2021</a> em R e documentar o
processo através desta
<a href="https://blog.curso-r.com/tags/advent-of-r/">série de posts</a>. Todo dia entre
01/12/2021 e 25/12/2021 eu vou tentar resolver o novo problema, documentar a
minha solução aqui no blog e subir os meus scripts completos para um
<a href="https://github.com/curso-r/advent-of-r">repositório público</a> no GitHub.</p>
<p>A minha esperança é que, com essa série, mais pessoas pratiquem seus
conhecimentos de R resolvendo exercícios divertidos e desafiadores! Ao final
da jornada vamos todos ter afiado nossas habilidades de R e, quem sabe,
divulgado essa linguagem incrível para mais pessoas. Boas festas e bom código!</p>
<div id="mapa-da-fossa-a" class="section level2">
<h2>Mapa da Fossa (A)</h2>
<p>Depois de um domingo assustadoramente difícil, o problema do
<a href="https://adventofcode.com/2021/day/20">dia 20</a> do AoC foi bastante tranquilo de
resolver. Tanto o enunciado quanto a solução me pareceram simples (apesar de
algumas reclamações na internet sobre uma pegadinha que vou explicar em breve).</p>
<p>Hoje nós recebemos uma imagem na forma de uma matriz composta por pontos
luminosos <code>#</code> e pontos escuros <code>.</code>. O outro componente da entrada era uma lista
de “conversões”: nós deveríamos converter cada quadrado 3x3 da imagem em um
número binário onde <code># = 1</code> e <code>. = 0</code> e encontrar o elemento de índice
correspondente da lista de conversões; o ponto do centro do quadrado deveria ser
substituido por esse elemento da lista.</p>
<pre class="r"><code># Um quadrado 3x3
# # . . # .
# #[. . .].
# #[# . .]#
# .[. # .].
# . . # # #
#
# Número correspondente
# ...#...#. = 000100010 = 34
#
# 34o elemento da lista de conversões
# 0         10        20        30 [34]   40        50        60        70
# |         |         |         |   |     |         |         |         |
# ..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##</code></pre>
<p>Entretanto, essa operação, denominada <em>realce</em>, tinha um detalhe a mais. A nossa
imagem de entrada era, na verdade, infinita! Em todas as direções, a imagem
deveria ser completa por infinitos pontos escuros. Nosso objetivo era contar o
número de pontos luminosos que restavam na nossa imagem após 2 aplicações do
realce.</p>
<p>Como é possível imaginar, os pontos escuros infinitos não podem fazer diferença
nessa contagem (senão a resposta seria incalculável). Note que um quadrado
composto só por pontos escuros equivale ao índice 0 da lista e, no exemplo
acima, isso é convertido para um novo ponto escuro; ou seja, as bordas infinitas
continuam sendo escuras após o realce.</p>
<p>A pegadinha, porém, era que a lista de conversões na entrada do problema
começava com <code>#</code> e não <code>.</code>, ou seja, os infinitos pontos escuros iam virar
infinitos pontos luminosos depois de um realce. Felizmente, na segunda
aplicação, todos os quadrados luminosos apontariam para o 511º elemento da lista
e esse sim era um <code>.</code>. Em conclusão, desde que aplicássemos um número par de
realces, as fronteiras infinitas da imagem seriam escuras e o número de pontos
luminosos poderia ser contado.</p>
<p>Sendo assim, o código que resolvia o problema era bem simples, bastava adicionar
uma borda escura à imagem para levar em conta a fronteira infinita e seguir em
frente.</p>
<pre class="r"><code># Converter uma região 3x3 em um número
img_to_int &lt;- function(image) {

  # Achatar a matriz para uma só coluna
  bits &lt;- ifelse(image == &quot;.&quot;, 0, 1)
  binary &lt;- paste0(as.vector(t(bits)), collapse = &quot;&quot;)

  # String para inteiro
  strtoi(binary, base = 2)
}

# Aplicar realce
enhance &lt;- function(image, algo) {

  # Iterar nas linhas e colunas, sem passar pela borda
  new_image &lt;- image
  for (i in 2:(nrow(image) - 1)) {
    for (j in 2:(ncol(image) - 1)) {

      # Trocar [i,j] pelo índice correspondente em `algo`
      ind &lt;- img_to_int(image[(-1:1 + i), (-1:1 + j)])
      new_image[i, j] &lt;- algo[ind + 1]
    }
  }

  # Remover borda e retornar
  new_image[2:(nrow(image) - 1), 2:(ncol(image) - 1)]
}

# Adicionar borda
add_padding &lt;- function(image) {

  # Adicionar mais 2 linhas em cima e embaixo
  image &lt;- rbind(
    image[1, ], image[1, ],
    image,
    image[nrow(image), ], image[nrow(image), ]
  )

  # Adicionar 2 colunas na esquerda e na direita
  image &lt;- cbind(
    image[, 1], image[, 1],
    image,
    image[, ncol(image)], image[, ncol(image)]
  )

  return(image)
}

# Ler lista de realce como um vetor de strings
algo &lt;- &quot;data-raw/20a_trench_map.txt&quot; |&gt;
  readr::read_lines(n_max = 1) |&gt;
  stringr::str_split(&quot;&quot;) |&gt;
  purrr::pluck(1)

# Ler imagem como uma matriz (e adicionar bordas)
image &lt;- &quot;data-raw/20a_trench_map.txt&quot; |&gt;
  readr::read_lines(skip = 2) |&gt;
  purrr::prepend(rep(paste0(rep(&quot;.&quot;, 100), collapse = &quot;&quot;), 3)) |&gt;
  append(rep(paste0(rep(&quot;.&quot;, 100), collapse = &quot;&quot;), 3)) |&gt;
  {\(s) stringr::str_c(&quot;...&quot;, s, &quot;...&quot;)}() |&gt;
  stringr::str_split(&quot;&quot;) |&gt;
  purrr::flatten_chr() |&gt;
  matrix(106, 106, byrow = TRUE)

# Aplicar o realce duas vezes e contar pontos luminosos
image |&gt;
  enhance(algo) |&gt;
  add_padding() |&gt;
  enhance(algo) |&gt;
  magrittr::equals(&quot;#&quot;) |&gt;
  sum()
#&gt; [1] 5498</code></pre>
</div>
<div id="mapa-da-fossa-b" class="section level2">
<h2>Mapa da Fossa (B)</h2>
<p>O segundo item pedia apenas para aplicarmos o algoritmo 50 ao invés de 2 vezes e
contar o número de pontos luminosos. Como o nosso algoritmo generaliza as
bordas, podemos simplesmente aplicá-lo mais vezes.</p>
<pre class="r"><code># Aplicar o realce 50 vezes
image &lt;- enhance(image, algo)
for (i in seq_len(49)) {
  image &lt;- enhance(add_padding(image), algo)
}

# Contar pontos luminosos
image |&gt;
  magrittr::equals(&quot;#&quot;) |&gt;
  sum()
#&gt; [1] 16014</code></pre>
</div>
