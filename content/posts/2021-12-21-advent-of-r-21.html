---
title: "Advent of R: Dia 21"
date: "2021-12-21"
tags: ["advent-of-r", "tidyverse"]
categories: ["Tutoriais"]
image: "images/posts/banner/advent-of-r-21.webp"
author: ["Caio"]
summary: "Resolvendo o Advent of Code 2021 com R: Dia 21."
draft: false
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>O <a href="https://adventofcode.com">Advent of Code</a> é um
<a href="https://pt.wikipedia.org/wiki/Calend%C3%A1rio_do_Advento">Calendário do Advento</a>
desenvolvido por <a href="https://github.com/topaz">Eric Wastl</a> composto por 25
pequenos exercícios de programação que vão sendo disponibilizados, um a um,
entre 1º de dezembro e o Natal de cada ano.</p>
<p>Meu objetivo com o <strong>Advent of R</strong> é resolver todos os problemas do
<a href="https://adventofcode.com/2021">Advent of Code 2021</a> em R e documentar o
processo através desta
<a href="https://blog.curso-r.com/tags/advent-of-r/">série de posts</a>. Todo dia entre
01/12/2021 e 25/12/2021 eu vou tentar resolver o novo problema, documentar a
minha solução aqui no blog e subir os meus scripts completos para um
<a href="https://github.com/curso-r/advent-of-r">repositório público</a> no GitHub.</p>
<p>A minha esperança é que, com essa série, mais pessoas pratiquem seus
conhecimentos de R resolvendo exercícios divertidos e desafiadores! Ao final
da jornada vamos todos ter afiado nossas habilidades de R e, quem sabe,
divulgado essa linguagem incrível para mais pessoas. Boas festas e bom código!</p>
<div id="dados-de-dirac-a" class="section level2">
<h2>Dados de Dirac (A)</h2>
<p>O <a href="https://adventofcode.com/2021/day/21">dia 21</a> do AoC começou bem. O primeiro
item foi bastante direto e tranquilo… O que complicou tudo foi o segundo.</p>
<p>Começamos aprendendo as regras de um jogo chamado Dados de Dirac. Ele é composto
um tabuleiro circular que vai de 1 a 10, um dado e dois peões para representar
os dois jogadores. Cada jogador rola o dado 3 vezes, soma os resultados e anda
aquele número de casas no tabuleiro; o número da casa em que ele caiu é então
adicionado à pontuação do jogador. Cada jogador começa em uma casa escolhida
aleatoriamente e ganha o primeiro a atingir 1000 ou mais pontos.</p>
<p>O primeiro item pedia para simularmos um jogo de Dados de Dirac com um dado
determinístico antes de partirmos para a versão oficial. Nós recebemos como
entrada a posição de início de cada jogador e a mecânica de funcionamento do
dado: ele ia de 1 a 100 e seu resultado sempre vinha nessa ordem (ou seja, o
primeiro jogador rolaria 1, 2, 3, o segundo rolaria 4, 5, 6, etc.). Nosso
objetivo era simular o jogo até que alguém ganhasse e retornar a pontuação do
jogador perdedor multiplicada pelo número de vezes que o dado foi rolado naquele
jogo.</p>
<pre class="r"><code># Ler posições iniciais
pos &lt;- &quot;data-raw/21a_dirac_dice.txt&quot; |&gt;
  readr::read_lines() |&gt;
  stringr::str_extract(&quot;[0-9]+$&quot;) |&gt;
  as.numeric()

# Posições iniciais
p1_pos &lt;- pos[1]
p2_pos &lt;- pos[2]

# Pontuações iniciais
p1_pts &lt;- 0
p2_pts &lt;- 0

# Fazer os dados irem do valor máximo para 1
die_mod &lt;- function(e1, e2) ((e1 - 1) %% e2) + 1

# Iterar até o jogo acabar
die &lt;- 1
counter &lt;- 0
while (TRUE) {

  # J1 rola 3 vezes
  p1_rolls &lt;- die:(die + 2)
  p1_rolls &lt;- die_mod(p1_rolls, 100)

  # Atualizar estado do dado e contador de rolagem
  die &lt;- die_mod(p1_rolls[3] + 1, 100)
  counter &lt;- counter + 3

  # Atualizar pontuação do J1
  p1_pos &lt;- p1_pos + sum(p1_rolls)
  p1_pos &lt;- die_mod(p1_pos, 10)
  p1_pts &lt;- p1_pts + p1_pos

  # Parar se J1 ganhou
  if (p1_pts &gt;= 1000) break

  # J2 rola 3 vezes
  p2_rolls &lt;- die:(die + 2)
  p2_rolls &lt;- die_mod(p2_rolls, 100)

  # Atualizar estado do dado e contador de rolagem
  die &lt;- die_mod(p2_rolls[3] + 1, 100)
  counter &lt;- counter + 3

  # Atualizar pontuação do J2
  p2_pos &lt;- p2_pos + sum(p2_rolls)
  p2_pos &lt;- die_mod(p2_pos, 10)
  p2_pts &lt;- p2_pts + p2_pos

  # Parar se J2 ganhou
  if (p2_pts &gt;= 1000) break
}

# Contador * pontuação do perdedor
min(p1_pts, p2_pts) * counter
#&gt; [1] 597600</code></pre>
</div>
<div id="dados-de-dirac-b" class="section level2">
<h2>Dados de Dirac (B)</h2>
<p>Bem direto, certo? Uma pena que o segundo item não tinha nada a ver… Agora
deveríamos simular o jogo com o epônimo Dado de Dirac. Ele tem 3 lados (de 1 a
3) e, cada vez que ele é rolado, um universo paralelo é criado para cada
possível resultado. Em suma, no final do jogo haveria um universo para cada
caminho que o jogo poderia hipoteticamente tomar. Felizmente, com o Dado de
Dirac, o jogo ia só até 21 pontos.</p>
<p>Nossa missão era, dadas as posições iniciais, calcular em quantos universos
ganhava o jogador que ganhava mais vezes. Não parece tão difícil até você
perceber que teremos algo em torno de 700 <em>trilhões</em> de universos para
considerar. Espero que esteja claro que tentar gerar todas as rodadas não vai
funcionar.</p>
<p>A solução ideal para esse problema é
<a href="https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_din%C3%A2mica">programação dinâmica</a>
(PD) que, apesar do nome esotérico, não é tão misteriosa assim. De forma bem
superficial, um algoritmo que usa PD começa dividindo o problema principal em
sub-problemas mais simples e armazenando seus resultados; a parte vital é,
então, utilizar esses resultados já calculados para evitar contas desnecessárias
mais para frente.</p>
<p>Concretamente, queremos dividir o jogo em estados distintos definidos pelos
quartetos <code>(p1_pos, p2_pos, p1_pts, p2_pts)</code>. Vejamos como funcionaria um trecho
desse algoritmo:</p>
<ol style="list-style-type: decimal">
<li><p>Começamos por um estado no final do jogo: <code>(3, 8, 19, 21)</code>. Neste universo,
sabemos que o J2 ganhou, então salvamos a informação <code>(3, 8, 19, 21) = (0, 1)</code>.</p></li>
<li><p>Mais para frente, encontramos o estado <code>(3, 5, 19, 13)</code>. O J2 pode rolar uma
série de valores aqui que precisamos verificar, mas, se ele rolar 1 + 1 + 1,
sabemos que cairemos no estado <code>(3, 8, 19, 21)</code>! Sendo assim, podemos pular este
cálculo e verificar apenas as outras rolagens possíveis.</p></li>
<li><p>Com PD, calcularemos primeiro estados mais fáceis e, conforme formos
evoluindo para o começo do jogo, já teremos calculado o número de vitórias de
cada jogador em cada futuro. Assim, basta somar esses futuros e passar para um
estado anterior.</p></li>
</ol>
<pre class="r"><code># Ler posições iniciais
pos &lt;- &quot;data-raw/21b_dirac_dice.txt&quot; |&gt;
  readr::read_lines() |&gt;
  stringr::str_extract(&quot;[0-9]+$&quot;) |&gt;
  as.numeric()

# Posições iniciais
p1_pos &lt;- pos[1]
p2_pos &lt;- pos[2]

# Fazer os dados irem do valor máximo para 1
die_mod &lt;- function(e1, e2) ((e1 - 1) %% e2) + 1

# Criar um identificar para `states`
id &lt;- function(a, b, c, d) paste0(a, &quot;,&quot;, b, &quot;,&quot;, c, &quot;,&quot;, d)

# Contar vitórias de cada jogador a partir de cada estado do jogo
states &lt;- list()
count_states &lt;- function(p1_pos, p2_pos, p1_pts = 0, p2_pts = 0) {
  this_id &lt;- id(p1_pos, p2_pos, p1_pts, p2_pts)

  # Condições de parada
  if (p1_pts &gt;= 21) return(c(1, 0))
  if (p2_pts &gt;= 21) return(c(0, 1))
  if (this_id %in% names(states)) return(states[[this_id]])

  # Todas as combinações possíveis de rolagens
  rolls &lt;- list(1:3, 1:3, 1:3) |&gt;
    purrr::cross() |&gt;
    purrr::map(purrr::flatten_int) |&gt;
    purrr::map_int(sum)

  # Iterar nas rolagens e fazer a recursão para os próximos estados
  wins_total &lt;- c(0, 0)
  for (roll in rolls) {
    p1_pos_ &lt;- die_mod(p1_pos + roll, 10)

    # Ir para o próximo estado e somar vitórias
    wins &lt;- count_states(p2_pos, p1_pos_, p2_pts, p1_pts + p1_pos_)
    wins_total &lt;- wins_total + rev(wins)
  }

  # Atualizar `states` e retornar
  states[[this_id]] &lt;&lt;- wins_total
  return(wins_total)
}

# Rodar programação dinâmica
count_states(p1_pos, p2_pos) |&gt;
  max() |&gt;
  format(scientific = FALSE)
#&gt; [1] 634769613696613</code></pre>
</div>
